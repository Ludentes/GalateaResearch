# Phase 1: Foundation Implementation Plan

> **Status: COMPLETE** — All 11 tasks done + 7 bonus tasks (multi-provider streaming, Langfuse, provider switcher).
> See [2026-02-04-phase1-progress.md](./2026-02-04-phase1-progress.md) for detailed progress and verification log.

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a working TanStack Start application with PostgreSQL (Drizzle), FalkorDB, and a basic chat UI that proves the infrastructure works end-to-end.

**Architecture:** TanStack Start full-stack React app with server functions + Nitro API routes. PostgreSQL via Drizzle ORM for relational data. FalkorDB (Docker) for graph storage. AI SDK v6 for multi-provider LLM streaming. All infrastructure in Docker Compose.

**Tech Stack:** TanStack Start v1.158 (Vite 7.3, Nitro 3.0.1-alpha.2), React 19, Drizzle ORM (PostgreSQL 17), FalkorDB, AI SDK v6, Docker Compose, Vitest 4, Playwright 1.58, Biome 2.3.14, shadcn/ui (new-york), Tailwind CSS 4, pnpm

**Reuse from ContextForgeTS:** Tailwind theme (oklch colors, dark mode), all UI components (button, input, label, toast, confirm-dialog, debounced-button), Vitest config, Playwright config, `cn()` utility, TypeScript strict settings.

---

## Prerequisites

- Node.js 20+ installed
- pnpm installed (`corepack enable && corepack prepare pnpm@latest --activate`)
- Docker & Docker Compose installed
- `ANTHROPIC_API_KEY` available (for chat in Task 9)

## ContextForgeTS Reference

Source location: `/home/newub/w/ContextLibrary/ContextForgeTS`

Files to copy/adapt:
- `src/index.css` → `app/styles/app.css` (Tailwind theme)
- `src/lib/utils.ts` → `app/lib/utils.ts`
- `src/components/ui/*` → `app/components/ui/*` (all 6 components)
- `vitest.config.ts` → adapted for TanStack Start paths
- `playwright.config.ts` → adapted for TanStack Start
- `components.json` → adapted paths (`app/` instead of `src/`)

## Success Criteria (from architecture doc)

> **Phase 1 Deliverable:** Working Galatea instance with database + graph ready
> **Success Metric:** Can store/retrieve from PostgreSQL and FalkorDB

---

## Task 1: Scaffold TanStack Start Project

**Files:**
- Create: `package.json`
- Create: `app.config.ts`
- Create: `tsconfig.json`
- Create: `app/routes/__root.tsx`
- Create: `app/routes/index.tsx`
- Create: `app/client.tsx`
- Create: `app/router.tsx`
- Create: `app/routeTree.gen.ts` (auto-generated)

**Step 1: Create project using TanStack CLI**

```bash
cd /home/newub/w
pnpm create @tanstack/start@latest galatea-app
```

When prompted, select:
- Package manager: pnpm
- Add-ons: TanStack Query (select it)
- Don't add Tailwind via CLI (we'll copy from ContextForgeTS)

Then move the generated files into the galatea repo:

```bash
# Copy generated app into existing galatea repo
cp -r galatea-app/* /home/newub/w/galatea/
cp galatea-app/.* /home/newub/w/galatea/ 2>/dev/null || true
rm -rf galatea-app
cd /home/newub/w/galatea
```

If the CLI doesn't work or has issues, fall back to manual setup:

```bash
cd /home/newub/w/galatea
pnpm init
pnpm add @tanstack/react-start @tanstack/react-router @tanstack/react-query react react-dom
pnpm add -D typescript @types/react @types/react-dom vite @vitejs/plugin-react @tanstack/router-plugin
```

**Step 2: Verify the project starts**

```bash
pnpm dev
```

Expected: Dev server starts, browser shows default page at `http://localhost:3000`.

**Step 3: Commit**

```bash
git add -A
git commit -m "feat: scaffold TanStack Start project with pnpm"
```

---

## Task 2: Biome + TypeScript Strict Config

**Files:**
- Create: `biome.json`
- Modify: `tsconfig.json` (match ContextForgeTS strictness)
- Modify: `package.json` (add biome, scripts)

**Step 1: Install Biome**

```bash
pnpm add -D @biomejs/biome
```

**Step 2: Create biome.json**

```json
{
  "$schema": "https://biomejs.dev/schemas/2.0.0/schema.json",
  "organizeImports": {
    "enabled": true
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 80
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "correctness": {
        "noUnusedImports": "warn",
        "noUnusedVariables": "warn"
      },
      "style": {
        "noNonNullAssertion": "off"
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "asNeeded"
    }
  },
  "files": {
    "ignore": [
      "node_modules",
      "dist",
      ".output",
      ".vinxi",
      ".tanstack",
      "server/db/migrations",
      "app/routeTree.gen.ts"
    ]
  }
}
```

**Step 3: Ensure TypeScript strict settings**

Match ContextForgeTS strictness. The tsconfig generated by TanStack Start may already be strict. Verify/add these settings:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./app/*"]
    }
  }
}
```

Note: Path alias `@/` maps to `./app/` (not `./src/`).

**Step 4: Add scripts to package.json**

```json
{
  "scripts": {
    "check": "biome check .",
    "fix": "biome check --write .",
    "format": "biome format --write ."
  }
}
```

**Step 5: Run Biome to verify**

```bash
pnpm check
```

Expected: No errors (maybe some warnings on generated files, which are ignored).

**Step 6: Commit**

```bash
git add biome.json tsconfig.json package.json pnpm-lock.yaml
git commit -m "feat: add Biome linter/formatter with TypeScript strict mode"
```

---

## Task 3: Tailwind CSS + shadcn/ui + UI Components from ContextForgeTS

**Files:**
- Create: `app/styles/app.css` (copied from ContextForgeTS `src/index.css`)
- Create: `app/lib/utils.ts` (copied from ContextForgeTS `src/lib/utils.ts`)
- Create: `app/components/ui/button.tsx` (copied)
- Create: `app/components/ui/input.tsx` (copied)
- Create: `app/components/ui/label.tsx` (copied)
- Create: `app/components/ui/toast.tsx` (copied)
- Create: `app/components/ui/confirm-dialog.tsx` (copied)
- Create: `app/components/ui/debounced-button.tsx` (copied)
- Create: `components.json` (adapted from ContextForgeTS)
- Modify: `app.config.ts` or `vite.config.ts` (add Tailwind plugin)
- Modify: `app/routes/__root.tsx` (import styles)
- Modify: `package.json` (add dependencies)

**Step 1: Install Tailwind CSS 4 + dependencies**

```bash
pnpm add tailwindcss tailwind-merge clsx class-variance-authority lucide-react tw-animate-css
pnpm add @radix-ui/react-slot @radix-ui/react-label
pnpm add -D @tailwindcss/vite
```

**Step 2: Copy the Tailwind theme CSS**

Copy `/home/newub/w/ContextLibrary/ContextForgeTS/src/index.css` to `app/styles/app.css`.

This is the exact file — oklch color system, dark mode, CSS variables, radius tokens:

```css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

**Step 3: Create the cn() utility**

Create `app/lib/utils.ts`:

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

**Step 4: Create components.json for shadcn/ui**

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/styles/app.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
```

**Step 5: Copy UI components from ContextForgeTS**

Copy all 6 files from `/home/newub/w/ContextLibrary/ContextForgeTS/src/components/ui/` to `app/components/ui/`:

- `button.tsx` — CVA variant button with Radix Slot
- `input.tsx` — Styled input with focus/error states
- `label.tsx` — Radix label with disabled states
- `toast.tsx` — Toast provider + context + `useToast()` hook
- `confirm-dialog.tsx` — Modal confirm dialog
- `debounced-button.tsx` — Button with click debouncing

These files use `@/lib/utils` and `@/components/ui/button` imports, which will resolve correctly since we're mapping `@/` to `app/`.

**Step 6: Add Tailwind Vite plugin to TanStack Start config**

In `app.config.ts` (TanStack Start config), add the Tailwind plugin:

```typescript
import tailwindcss from "@tailwindcss/vite"

// Add to the vite plugins array:
// plugins: [tailwindcss()]
```

The exact config format depends on what TanStack Start generated. Look for the Vite config section and add `tailwindcss()` to plugins.

Also ensure the path alias is configured in the Vite resolve section:

```typescript
resolve: {
  alias: {
    "@": path.resolve(__dirname, "./app"),
  },
}
```

**Step 7: Import styles in root layout**

In `app/routes/__root.tsx`, import the CSS file. In TanStack Start, this is typically done via the `links` function or a direct import:

```typescript
import "../styles/app.css"
```

**Step 8: Verify Tailwind + components work**

Update `app/routes/index.tsx` to render a Button:

```tsx
import { createFileRoute } from "@tanstack/react-router"
import { Button } from "@/components/ui/button"

export const Route = createFileRoute("/")({
  component: HomePage,
})

function HomePage() {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen gap-4">
      <h1 className="text-4xl font-bold">Galatea</h1>
      <p className="text-muted-foreground">Psychological Architecture + LLM</p>
      <Button size="lg">Get Started</Button>
    </div>
  )
}
```

Run `pnpm dev` and verify:
- Background color uses the theme (white/dark)
- Button renders with primary styling
- `text-muted-foreground` renders correctly (gray text)

**Step 9: Commit**

```bash
git add app/styles/ app/lib/ app/components/ui/ components.json app.config.ts app/routes/
git commit -m "feat: add Tailwind CSS 4 theme, shadcn/ui, and UI components from ContextForgeTS"
```

---

## Task 4: Vitest + Playwright Test Config

**Files:**
- Create: `vitest.config.ts` (adapted from ContextForgeTS)
- Create: `playwright.config.ts` (adapted from ContextForgeTS)
- Create: `app/test/setup.ts`
- Modify: `package.json` (add test dependencies and scripts)

**Step 1: Install test dependencies**

```bash
pnpm add -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom @playwright/test
```

**Step 2: Create vitest.config.ts**

Adapted from ContextForgeTS — changed path alias from `src/` to `app/`:

```typescript
import { defineConfig } from "vitest/config"
import react from "@vitejs/plugin-react"
import path from "path"

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    globals: true,
    setupFiles: ["./app/test/setup.ts"],
    exclude: ["node_modules", "e2e"],
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./app"),
    },
  },
})
```

**Step 3: Create test setup**

Create `app/test/setup.ts`:

```typescript
import "@testing-library/jest-dom/vitest"
```

**Step 4: Create playwright.config.ts**

Adapted from ContextForgeTS — uses pnpm, TanStack Start port:

```typescript
import { defineConfig, devices } from "@playwright/test"

export default defineConfig({
  testDir: "./e2e",
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: "html",
  use: {
    baseURL: "http://localhost:3000",
    trace: "on-first-retry",
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
  webServer: {
    command: "pnpm dev",
    url: "http://localhost:3000",
    reuseExistingServer: !process.env.CI,
  },
})
```

**Step 5: Add test scripts to package.json**

```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

**Step 6: Write a smoke test for Button component**

Create `app/components/ui/__tests__/button.test.tsx`:

```tsx
import { describe, it, expect } from "vitest"
import { render, screen } from "@testing-library/react"
import { Button } from "@/components/ui/button"

describe("Button", () => {
  it("renders button with text", () => {
    render(<Button>Click me</Button>)
    expect(
      screen.getByRole("button", { name: /click me/i })
    ).toBeInTheDocument()
  })

  it("applies variant classes", () => {
    render(<Button variant="destructive">Delete</Button>)
    const button = screen.getByRole("button", { name: /delete/i })
    expect(button).toHaveAttribute("data-variant", "destructive")
  })
})
```

**Step 7: Run the test**

```bash
pnpm test -- app/components/ui/__tests__/button.test.tsx
```

Expected: 2 tests PASS.

**Step 8: Commit**

```bash
git add vitest.config.ts playwright.config.ts app/test/ app/components/ui/__tests__/ package.json pnpm-lock.yaml
git commit -m "feat: add Vitest and Playwright test config from ContextForgeTS patterns"
```

---

## Task 5: Docker Compose Infrastructure

**Files:**
- Create: `docker-compose.yml`
- Create: `mosquitto/mosquitto.conf`
- Create: `.env.example`
- Create: `.env.local` (gitignored)
- Modify: `.gitignore` (ensure `.env.local` is ignored)

**Step 1: Write docker-compose.yml**

```yaml
services:
  postgres:
    image: postgres:17
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: galatea
      POSTGRES_USER: galatea
      POSTGRES_PASSWORD: galatea
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U galatea"]
      interval: 5s
      timeout: 5s
      retries: 5

  falkordb:
    image: falkordb/falkordb:latest
    ports:
      - "6379:6379"
    volumes:
      - falkordb_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5

  mosquitto:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf

volumes:
  postgres_data:
  falkordb_data:
```

**Step 2: Write Mosquitto config**

Create `mosquitto/mosquitto.conf`:

```
listener 1883
allow_anonymous true
listener 9001
protocol websockets
```

**Step 3: Write .env.example**

```bash
# Database
DATABASE_URL=postgres://galatea:galatea@localhost:5432/galatea

# Auth (generate with: openssl rand -base64 32)
BETTER_AUTH_SECRET=change-me-in-env-local

# LLM
ANTHROPIC_API_KEY=sk-ant-...

# Graph Memory
FALKORDB_URL=redis://localhost:6379

# Embeddings (optional for Phase 1)
# VOYAGE_AI_API_KEY=pa-...

# Events
MQTT_BROKER_URL=mqtt://localhost:1883

# Observability (optional for Phase 1)
# LANGFUSE_SECRET_KEY=sk-lf-...
# LANGFUSE_PUBLIC_KEY=pk-lf-...

# Content
KNOWLEDGE_PATH=./galatea-knowledge
```

**Step 4: Create .env.local by copying .env.example**

```bash
cp .env.example .env.local
```

Edit `.env.local` with real `ANTHROPIC_API_KEY`.

**Step 5: Verify .gitignore includes .env.local**

Ensure `.env.local` is in `.gitignore`. Also add Docker/build ignores:

```
.env.local
.output/
.vinxi/
dist/
```

**Step 6: Start Docker services**

```bash
docker compose up -d
```

**Step 7: Verify all three services are healthy**

```bash
docker compose ps
```

Expected: All three containers running. Then:

```bash
# Test PostgreSQL
docker compose exec postgres psql -U galatea -c "SELECT 1"

# Test FalkorDB
docker compose exec falkordb redis-cli PING

# Test Mosquitto (just check it's running)
docker compose logs mosquitto | head -5
```

**Step 8: Commit**

```bash
git add docker-compose.yml mosquitto/mosquitto.conf .env.example .gitignore
git commit -m "feat: add Docker Compose with PostgreSQL, FalkorDB, Mosquitto"
```

---

## Task 6: Drizzle ORM Setup + Schema

**Files:**
- Create: `server/db/schema.ts`
- Create: `server/db/index.ts`
- Create: `drizzle.config.ts`
- Modify: `package.json` (add drizzle dependencies + scripts)

**Step 1: Install Drizzle dependencies**

```bash
pnpm add drizzle-orm postgres
pnpm add -D drizzle-kit tsx
```

Note: `postgres` is the postgres.js driver (no native dependencies). `tsx` is for running seed scripts.

**Step 2: Create drizzle.config.ts**

```typescript
import { defineConfig } from "drizzle-kit"

export default defineConfig({
  dialect: "postgresql",
  schema: "./server/db/schema.ts",
  out: "./server/db/migrations",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
})
```

**Step 3: Create the database schema**

Create `server/db/schema.ts`. Phase 1 tables only — sessions, messages, personas, preprompts:

```typescript
import {
  pgTable,
  text,
  integer,
  boolean,
  timestamp,
  jsonb,
  uuid,
} from "drizzle-orm/pg-core"

// ============ Personas ============

export const personas = pgTable("personas", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull(),
  role: text("role").notNull(),
  domain: text("domain").notNull(),
  thresholds: jsonb("thresholds").$type<{
    certaintyAlignment?: { context: string; value?: number }
    communicationHealth?: { context: string; intervalMinutes?: number }
    knowledgeApplication?: { context: string; maxResearchMinutes?: number }
  }>(),
  active: boolean("active").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
})

// ============ Sessions ============

export const sessions = pgTable("sessions", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull(),
  personaId: uuid("persona_id").references(() => personas.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  lastActiveAt: timestamp("last_active_at"),
})

// ============ Messages ============

export const messages = pgTable("messages", {
  id: uuid("id").defaultRandom().primaryKey(),
  sessionId: uuid("session_id")
    .references(() => sessions.id)
    .notNull(),
  role: text("role", { enum: ["user", "assistant", "system"] }).notNull(),
  content: text("content").notNull(),
  activityLevel: integer("activity_level"),
  model: text("model"),
  tokenCount: integer("token_count"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
})

// ============ Preprompts ============

export const preprompts = pgTable("preprompts", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull().unique(),
  type: text("type", {
    enum: ["core", "persona", "hard_rule", "domain"],
  }).notNull(),
  content: text("content").notNull(),
  priority: integer("priority").default(0),
  active: boolean("active").default(true),
})
```

**Step 4: Create the database client**

Create `server/db/index.ts`:

```typescript
import { drizzle } from "drizzle-orm/postgres-js"
import postgres from "postgres"
import * as schema from "./schema"

const connectionString = process.env.DATABASE_URL!
const client = postgres(connectionString)

export const db = drizzle(client, { schema })
```

**Step 5: Push schema to database**

```bash
pnpm drizzle-kit push
```

**Step 6: Add scripts to package.json**

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio",
    "db:seed": "tsx server/db/seed.ts"
  }
}
```

**Step 7: Verify schema was applied**

```bash
docker compose exec postgres psql -U galatea -c "\dt"
```

Expected: Tables `sessions`, `messages`, `personas`, `preprompts` listed.

**Step 8: Commit**

```bash
git add server/db/ drizzle.config.ts package.json pnpm-lock.yaml
git commit -m "feat: add Drizzle ORM schema with sessions, messages, personas, preprompts"
```

---

## Task 7: Database + FalkorDB Integration Tests

**Files:**
- Create: `server/db/__tests__/schema.test.ts`
- Create: `server/integrations/falkordb.ts`
- Create: `server/integrations/__tests__/falkordb.test.ts`

**Step 1: Install FalkorDB client**

```bash
pnpm add falkordb
```

**Step 2: Create FalkorDB client wrapper**

Create `server/integrations/falkordb.ts`:

```typescript
import { FalkorDB } from "falkordb"

const FALKORDB_URL = process.env.FALKORDB_URL || "redis://localhost:6379"

let falkorInstance: FalkorDB | null = null

export async function getFalkorDB(): Promise<FalkorDB> {
  if (!falkorInstance) {
    falkorInstance = await FalkorDB.connect({
      socket: {
        host: new URL(FALKORDB_URL).hostname,
        port: parseInt(new URL(FALKORDB_URL).port || "6379"),
      },
    })
  }
  return falkorInstance
}

export async function getGraph(name = "galatea") {
  const db = await getFalkorDB()
  return db.selectGraph(name)
}

export async function closeFalkorDB(): Promise<void> {
  if (falkorInstance) {
    await falkorInstance.close()
    falkorInstance = null
  }
}
```

**Step 3: Write database schema tests**

Create `server/db/__tests__/schema.test.ts`:

```typescript
import { describe, it, expect, afterAll } from "vitest"
import { drizzle } from "drizzle-orm/postgres-js"
import postgres from "postgres"
import { sessions, messages, personas, preprompts } from "../schema"
import { eq } from "drizzle-orm"

const TEST_DB_URL =
  process.env.DATABASE_URL || "postgres://galatea:galatea@localhost:5432/galatea"

describe("Drizzle Schema", () => {
  const client = postgres(TEST_DB_URL)
  const db = drizzle(client)

  afterAll(async () => {
    await client.end()
  })

  it("creates and retrieves a session", async () => {
    const [session] = await db
      .insert(sessions)
      .values({ name: "Test Session" })
      .returning()

    expect(session.id).toBeDefined()
    expect(session.name).toBe("Test Session")

    await db.delete(sessions).where(eq(sessions.id, session.id))
  })

  it("creates a message linked to a session", async () => {
    const [session] = await db
      .insert(sessions)
      .values({ name: "Test Session" })
      .returning()

    const [message] = await db
      .insert(messages)
      .values({
        sessionId: session.id,
        role: "user",
        content: "Hello, Galatea",
      })
      .returning()

    expect(message.sessionId).toBe(session.id)
    expect(message.content).toBe("Hello, Galatea")

    await db.delete(messages).where(eq(messages.id, message.id))
    await db.delete(sessions).where(eq(sessions.id, session.id))
  })

  it("creates a persona with JSON thresholds", async () => {
    const [persona] = await db
      .insert(personas)
      .values({
        name: "Test Programmer",
        role: "Mobile Developer",
        domain: "expo-react-native",
        thresholds: {
          certaintyAlignment: {
            context: "Architecture questions",
            value: 0.8,
          },
        },
      })
      .returning()

    expect(persona.thresholds).toEqual({
      certaintyAlignment: {
        context: "Architecture questions",
        value: 0.8,
      },
    })

    await db.delete(personas).where(eq(personas.id, persona.id))
  })

  it("creates a preprompt with unique name", async () => {
    const [preprompt] = await db
      .insert(preprompts)
      .values({
        name: "test-core-identity",
        type: "core",
        content: "You are Galatea, an AI agent.",
        priority: 100,
      })
      .returning()

    expect(preprompt.type).toBe("core")
    expect(preprompt.priority).toBe(100)

    await db.delete(preprompts).where(eq(preprompts.id, preprompt.id))
  })
})
```

**Step 4: Write FalkorDB tests**

Create `server/integrations/__tests__/falkordb.test.ts`:

```typescript
import { describe, it, expect, afterAll } from "vitest"
import { getGraph, closeFalkorDB } from "../falkordb"

describe("FalkorDB Connection", () => {
  afterAll(async () => {
    await closeFalkorDB()
  })

  it("connects and creates a test node", async () => {
    const graph = await getGraph("galatea_test")

    await graph.query(
      "CREATE (n:TestNode {name: $name, created: $created})",
      { params: { name: "smoke-test", created: Date.now() } }
    )

    const result = await graph.query(
      "MATCH (n:TestNode {name: 'smoke-test'}) RETURN n.name AS name"
    )

    expect(result.data?.length).toBeGreaterThan(0)
    expect(result.data?.[0]?.name).toBe("smoke-test")

    await graph.query("MATCH (n:TestNode) DELETE n")
  })

  it("creates and queries edges between nodes", async () => {
    const graph = await getGraph("galatea_test")

    await graph.query(
      "CREATE (a:Memory {type: 'fact', content: 'Prefer Clerk'})-[:RELATED_TO]->(b:Memory {type: 'preference', content: 'Auth library'})"
    )

    const result = await graph.query(
      "MATCH (a:Memory)-[:RELATED_TO]->(b:Memory) RETURN a.content AS from_content, b.content AS to_content"
    )

    expect(result.data?.length).toBe(1)
    expect(result.data?.[0]?.from_content).toBe("Prefer Clerk")

    await graph.query("MATCH (n:Memory) DETACH DELETE n")
  })
})
```

**Step 5: Run all tests**

```bash
pnpm test
```

Expected: 6 tests PASS (4 schema + 2 FalkorDB). If FalkorDB tests fail, check Docker is running: `docker compose ps`.

**Step 6: Commit**

```bash
git add server/db/__tests__/ server/integrations/ package.json pnpm-lock.yaml
git commit -m "test: add Drizzle schema and FalkorDB integration tests"
```

---

## Task 8: Seed Data (Default Personas + Preprompts)

**Files:**
- Create: `server/db/seed.ts`

**Step 1: Create seed script**

Create `server/db/seed.ts`:

```typescript
import { drizzle } from "drizzle-orm/postgres-js"
import postgres from "postgres"
import { personas, preprompts } from "./schema"

const connectionString =
  process.env.DATABASE_URL || "postgres://galatea:galatea@localhost:5432/galatea"

async function seed() {
  const client = postgres(connectionString)
  const db = drizzle(client)

  console.log("Seeding database...")

  await db
    .insert(personas)
    .values({
      name: "Expo Developer Agent",
      role: "Mobile Developer",
      domain: "expo-react-native",
      thresholds: {
        certaintyAlignment: {
          context: "Architecture and preference questions",
          value: 0.8,
        },
        communicationHealth: {
          context: "During active work sessions",
          intervalMinutes: 120,
        },
        knowledgeApplication: {
          context: "Research before implementation",
          maxResearchMinutes: 60,
        },
      },
    })
    .onConflictDoNothing()

  await db
    .insert(personas)
    .values({
      name: "Personal Assistant",
      role: "Assistant",
      domain: "general",
      thresholds: {
        certaintyAlignment: {
          context: "User preference questions",
          value: 0.6,
        },
        communicationHealth: {
          context: "Regular check-ins",
          intervalMinutes: 240,
        },
      },
    })
    .onConflictDoNothing()

  await db
    .insert(preprompts)
    .values({
      name: "core-identity",
      type: "core",
      content: `You are Galatea, an AI agent with psychological architecture.

You have a memory system that tracks what you've learned, and a homeostasis system that guides your behavior across six dimensions: knowledge sufficiency, certainty alignment, progress momentum, communication health, productive engagement, and knowledge application.

You aim to be helpful, honest, and appropriately calibrated in your responses. When you lack knowledge, you say so. When you're confident, you act. You learn from interactions and improve over time.`,
      priority: 100,
      active: true,
    })
    .onConflictDoNothing()

  await db
    .insert(preprompts)
    .values({
      name: "hard-rule-no-push-main",
      type: "hard_rule",
      content: "HARD RULE: Never push directly to the main branch.",
      priority: 200,
      active: true,
    })
    .onConflictDoNothing()

  console.log("Seed complete.")
  await client.end()
}

seed().catch(console.error)
```

**Step 2: Run the seed**

```bash
pnpm db:seed
```

Expected: "Seeding database..." then "Seed complete."

**Step 3: Verify seed data**

```bash
docker compose exec postgres psql -U galatea -c "SELECT name, role FROM personas"
docker compose exec postgres psql -U galatea -c "SELECT name, type FROM preprompts"
```

Expected: 2 personas, 2 preprompts.

**Step 4: Commit**

```bash
git add server/db/seed.ts
git commit -m "feat: add database seed with default personas and preprompts"
```

---

## Task 9: Chat Server Function + AI SDK

**Files:**
- Create: `server/functions/chat.ts`
- Modify: `package.json` (add AI SDK dependencies)

**Step 1: Install Vercel AI SDK**

```bash
pnpm add ai @ai-sdk/anthropic
```

**Step 2: Create the chat server function**

Create `server/functions/chat.ts`:

```typescript
import { createServerFn } from "@tanstack/react-start/server"
import { streamText } from "ai"
import { anthropic } from "@ai-sdk/anthropic"
import { db } from "../db"
import { sessions, messages, preprompts } from "../db/schema"
import { eq } from "drizzle-orm"

export const sendMessage = createServerFn({ method: "POST" })
  .validator((input: { sessionId: string; message: string }) => input)
  .handler(async ({ input }) => {
    const { sessionId, message } = input

    // Store user message
    await db.insert(messages).values({
      sessionId,
      role: "user",
      content: message,
    })

    // Get conversation history
    const history = await db
      .select()
      .from(messages)
      .where(eq(messages.sessionId, sessionId))
      .orderBy(messages.createdAt)

    // Get active preprompts (core + hard rules)
    const activePrompts = await db
      .select()
      .from(preprompts)
      .where(eq(preprompts.active, true))
      .orderBy(preprompts.priority)

    // Build system prompt
    const systemPrompt = activePrompts.map((p) => p.content).join("\n\n")

    // Stream response
    const result = streamText({
      model: anthropic("claude-sonnet-4-20250514"),
      system: systemPrompt,
      messages: history.map((m) => ({
        role: m.role as "user" | "assistant",
        content: m.content,
      })),
    })

    // Store assistant response after streaming completes
    result.then(async (r) => {
      const fullText = await r.text
      await db.insert(messages).values({
        sessionId,
        role: "assistant",
        content: fullText,
      })
    })

    return result
  })

export const createSession = createServerFn({ method: "POST" })
  .validator((input: { name: string }) => input)
  .handler(async ({ input }) => {
    const [session] = await db
      .insert(sessions)
      .values({ name: input.name })
      .returning()
    return session
  })

export const getSessionMessages = createServerFn({ method: "GET" })
  .validator((input: { sessionId: string }) => input)
  .handler(async ({ input }) => {
    return db
      .select()
      .from(messages)
      .where(eq(messages.sessionId, input.sessionId))
      .orderBy(messages.createdAt)
  })
```

**Step 3: Verify it compiles**

```bash
pnpm exec tsc --noEmit
```

Expected: No type errors. If there are issues with TanStack Start server function imports, check the actual API — it may be `@tanstack/start/server` or similar.

**Step 4: Commit**

```bash
git add server/functions/ package.json pnpm-lock.yaml
git commit -m "feat: add chat server function with Vercel AI SDK streaming"
```

---

## Task 10: Chat UI

**Files:**
- Create: `app/components/chat/MessageList.tsx`
- Create: `app/components/chat/ChatInput.tsx`
- Create: `app/routes/chat/$sessionId.tsx`
- Modify: `app/routes/index.tsx` (add session creation)

**Step 1: Create MessageList component**

Create `app/components/chat/MessageList.tsx`:

```tsx
import { useRef, useEffect } from "react"
import { cn } from "@/lib/utils"

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  createdAt: string
}

export function MessageList({ messages }: { messages: Message[] }) {
  const bottomRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" })
  }, [messages.length])

  return (
    <div className="flex-1 overflow-y-auto p-4">
      <div className="space-y-4 max-w-3xl mx-auto">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={cn(
              "flex",
              msg.role === "user" ? "justify-end" : "justify-start"
            )}
          >
            <div
              className={cn(
                "max-w-[80%] rounded-lg p-3",
                msg.role === "user"
                  ? "bg-primary text-primary-foreground"
                  : "bg-muted text-foreground"
              )}
            >
              <p className="whitespace-pre-wrap text-sm">{msg.content}</p>
            </div>
          </div>
        ))}
        <div ref={bottomRef} />
      </div>
    </div>
  )
}
```

**Step 2: Create ChatInput component**

Create `app/components/chat/ChatInput.tsx`:

```tsx
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

interface ChatInputProps {
  onSend: (message: string) => void
  disabled?: boolean
}

export function ChatInput({ onSend, disabled }: ChatInputProps) {
  const [input, setInput] = useState("")

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!input.trim()) return
    onSend(input.trim())
    setInput("")
  }

  return (
    <form
      onSubmit={handleSubmit}
      className="flex gap-2 p-4 border-t border-border max-w-3xl mx-auto w-full"
    >
      <Input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Message Galatea..."
        disabled={disabled}
        className="flex-1"
      />
      <Button type="submit" disabled={disabled || !input.trim()}>
        Send
      </Button>
    </form>
  )
}
```

**Step 3: Create chat route**

Create `app/routes/chat/$sessionId.tsx`:

```tsx
import { createFileRoute } from "@tanstack/react-router"
import { useState, useEffect } from "react"
import { MessageList } from "@/components/chat/MessageList"
import { ChatInput } from "@/components/chat/ChatInput"
import {
  getSessionMessages,
  sendMessage,
} from "../../../server/functions/chat"

export const Route = createFileRoute("/chat/$sessionId")({
  component: ChatPage,
})

function ChatPage() {
  const { sessionId } = Route.useParams()
  const [messages, setMessages] = useState<any[]>([])
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    getSessionMessages({ data: { sessionId } }).then(setMessages)
  }, [sessionId])

  const handleSend = async (content: string) => {
    const userMsg = {
      id: crypto.randomUUID(),
      role: "user" as const,
      content,
      createdAt: new Date().toISOString(),
    }
    setMessages((prev) => [...prev, userMsg])
    setLoading(true)

    try {
      await sendMessage({ data: { sessionId, message: content } })
      const updated = await getSessionMessages({ data: { sessionId } })
      setMessages(updated)
    } catch (error) {
      console.error("Chat error:", error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="flex flex-col h-screen">
      <header className="p-4 border-b border-border">
        <h1 className="text-xl font-semibold">Galatea Chat</h1>
      </header>
      <MessageList messages={messages} />
      <ChatInput onSend={handleSend} disabled={loading} />
    </div>
  )
}
```

**Step 4: Update index route with session creation**

Update `app/routes/index.tsx`:

```tsx
import { createFileRoute, useNavigate } from "@tanstack/react-router"
import { Button } from "@/components/ui/button"
import { createSession } from "../../server/functions/chat"

export const Route = createFileRoute("/")({
  component: HomePage,
})

function HomePage() {
  const navigate = useNavigate()

  const handleNewChat = async () => {
    const session = await createSession({
      data: { name: `Chat ${new Date().toLocaleDateString()}` },
    })
    navigate({ to: "/chat/$sessionId", params: { sessionId: session.id } })
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen gap-4">
      <h1 className="text-4xl font-bold">Galatea</h1>
      <p className="text-muted-foreground">
        Psychological Architecture + LLM
      </p>
      <Button onClick={handleNewChat} size="lg">
        New Chat
      </Button>
    </div>
  )
}
```

**Step 5: Verify the chat flow works**

1. Start Docker services: `docker compose up -d`
2. Run seed: `pnpm db:seed`
3. Start dev server: `pnpm dev`
4. Open browser, click "New Chat"
5. Type a message and send
6. Verify response appears

**Step 6: Commit**

```bash
git add app/components/chat/ app/routes/
git commit -m "feat: add basic chat UI with message history and LLM streaming"
```

---

## Task 11: End-to-End Foundation Verification

**Files:**
- Create: `server/__tests__/e2e-foundation.test.ts`

**Step 1: Write the end-to-end verification test**

This test verifies the Phase 1 success metric: "Can store/retrieve from PostgreSQL and FalkorDB."

Create `server/__tests__/e2e-foundation.test.ts`:

```typescript
import { describe, it, expect, afterAll } from "vitest"
import { drizzle } from "drizzle-orm/postgres-js"
import postgres from "postgres"
import { sessions, messages, preprompts } from "../db/schema"
import { eq } from "drizzle-orm"
import { getGraph, closeFalkorDB } from "../integrations/falkordb"

const TEST_DB_URL =
  process.env.DATABASE_URL || "postgres://galatea:galatea@localhost:5432/galatea"

describe("Phase 1 Foundation E2E", () => {
  const client = postgres(TEST_DB_URL)
  const db = drizzle(client)

  afterAll(async () => {
    await client.end()
    await closeFalkorDB()
  })

  it("PostgreSQL: full session lifecycle", async () => {
    const [session] = await db
      .insert(sessions)
      .values({ name: "E2E Test Session" })
      .returning()

    await db.insert(messages).values([
      { sessionId: session.id, role: "user", content: "Hello" },
      { sessionId: session.id, role: "assistant", content: "Hi there!" },
    ])

    const msgs = await db
      .select()
      .from(messages)
      .where(eq(messages.sessionId, session.id))
      .orderBy(messages.createdAt)

    expect(msgs).toHaveLength(2)
    expect(msgs[0].role).toBe("user")
    expect(msgs[1].role).toBe("assistant")

    await db.delete(messages).where(eq(messages.sessionId, session.id))
    await db.delete(sessions).where(eq(sessions.id, session.id))
  })

  it("FalkorDB: store and retrieve memory node", async () => {
    const graph = await getGraph("galatea_test")

    await graph.query(
      `CREATE (m:Memory {
        type: $type,
        content: $content,
        confidence: $confidence,
        created_at: $created_at
      })`,
      {
        params: {
          type: "semantic:fact",
          content: "Prefer Clerk for authentication",
          confidence: 0.85,
          created_at: Date.now(),
        },
      }
    )

    const result = await graph.query(
      "MATCH (m:Memory {type: 'semantic:fact'}) RETURN m.content AS content, m.confidence AS confidence"
    )

    expect(result.data?.length).toBeGreaterThan(0)
    expect(result.data?.[0]?.content).toBe("Prefer Clerk for authentication")
    expect(result.data?.[0]?.confidence).toBe(0.85)

    await graph.query("MATCH (n:Memory) DETACH DELETE n")
  })

  it("PostgreSQL: preprompts queried by type", async () => {
    const [core] = await db
      .insert(preprompts)
      .values({
        name: "e2e-core-test",
        type: "core",
        content: "Core identity text",
        priority: 100,
      })
      .returning()

    const [rule] = await db
      .insert(preprompts)
      .values({
        name: "e2e-rule-test",
        type: "hard_rule",
        content: "Never delete production data",
        priority: 200,
      })
      .returning()

    const hardRules = await db
      .select()
      .from(preprompts)
      .where(eq(preprompts.type, "hard_rule"))

    const ruleContents = hardRules.map((r) => r.content)
    expect(ruleContents).toContain("Never delete production data")

    await db.delete(preprompts).where(eq(preprompts.id, core.id))
    await db.delete(preprompts).where(eq(preprompts.id, rule.id))
  })
})
```

**Step 2: Run the full test suite**

```bash
pnpm test
```

Expected: All tests pass (button smoke test + schema tests + FalkorDB tests + E2E tests).

**Step 3: Commit**

```bash
git add server/__tests__/
git commit -m "test: add Phase 1 end-to-end foundation tests"
```

---

## Phase 1 Completion Checklist

After all tasks are done, verify:

- [ ] `docker compose up -d` starts PostgreSQL, FalkorDB, Mosquitto
- [ ] `pnpm dev` starts TanStack Start dev server
- [ ] Can create a chat session via the UI
- [ ] Can send a message and receive an LLM response
- [ ] Messages persist in PostgreSQL across page refreshes
- [ ] FalkorDB accepts graph queries (nodes + edges)
- [ ] `pnpm test` — all tests pass
- [ ] `pnpm check` — Biome passes
- [ ] Dark mode works (add `.dark` class to `<html>`)
- [ ] UI components render correctly (Button, Input, Toast)
- [ ] Drizzle Studio accessible via `pnpm db:studio`

**Phase 1 is complete when the success metric is met:**
> Can store/retrieve from PostgreSQL and FalkorDB

---

## Notes for Implementer

### What Was Copied from ContextForgeTS

| From ContextForgeTS | To Galatea | Changes |
|---------------------|------------|---------|
| `src/index.css` | `app/styles/app.css` | None (exact copy) |
| `src/lib/utils.ts` | `app/lib/utils.ts` | None (exact copy) |
| `src/components/ui/button.tsx` | `app/components/ui/button.tsx` | None |
| `src/components/ui/input.tsx` | `app/components/ui/input.tsx` | None |
| `src/components/ui/label.tsx` | `app/components/ui/label.tsx` | None |
| `src/components/ui/toast.tsx` | `app/components/ui/toast.tsx` | None |
| `src/components/ui/confirm-dialog.tsx` | `app/components/ui/confirm-dialog.tsx` | None |
| `src/components/ui/debounced-button.tsx` | `app/components/ui/debounced-button.tsx` | None |
| `vitest.config.ts` | `vitest.config.ts` | Path alias: `src/` → `app/` |
| `playwright.config.ts` | `playwright.config.ts` | Port: 5173 → 3000 |
| `components.json` | `components.json` | CSS path: `src/index.css` → `app/styles/app.css` |

### Code Style (Biome)

- Double quotes (matching ContextForgeTS)
- No semicolons (matching ContextForgeTS)
- 2-space indent
- 80 char line width
- All code in the plan follows this style

### TanStack Start API Caveats

TanStack Start is in Release Candidate stage. Key things to check:
- Import paths: may be `@tanstack/start` instead of `@tanstack/react-start/server`
- Server function invocation: may need `.call()` or different syntax
- Streaming: check if `streamText` result integrates with TanStack Start's response handling
- Path aliases: verify TanStack Start resolves `@/` correctly in both client and server code

When in doubt, check the [TanStack Start docs](https://tanstack.com/start/latest/docs/framework/react/getting-started) and the [start-basic example](https://github.com/TanStack/router/tree/main/examples/react/start-basic).

### FalkorDB Client

The `falkordb` npm package may have a different API than shown. Check the actual package docs. The core operations are:
1. Connect to Redis-compatible server
2. Select a named graph
3. Run Cypher queries

If `falkordb` npm package doesn't work, fall back to `redis` package with `GRAPH.QUERY` commands.

### Schema Decisions

- `uuid` with `defaultRandom()` for primary keys (PostgreSQL `gen_random_uuid()`)
- `timestamp` type (cleaner than `integer` with `mode: 'timestamp'`)
- `jsonb` for flexible JSON fields (thresholds, etc.)
- Minimal schema for Phase 1 — more tables added in later phases

### What's Deferred to Phase 2+

- `homeostasis_state` table → Phase 3
- `self_models`, `user_models`, `domain_models`, `relationship_models` → Phase 3
- `observations` table → Phase 2/5
- `tool_executions` table → Phase 4
- Graphiti integration (Python wrapper) → Phase 2
- MQTT subscriber → Phase 2/5
- Better Auth → Phase 2 (not needed for single-user local dev)
- DnD system → Phase 2 (memory browser)
- Dark mode toggle → Task 10 or later (theme CSS is ready, just needs toggle)
